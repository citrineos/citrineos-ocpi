/* eslint-disable */
import * as types from './graphql';
import { TypedDocumentNode as DocumentNode } from '@graphql-typed-document-node/core';

/**
 * Map of all GraphQL operations in the project.
 *
 * This map has several performance disadvantages:
 * 1. It is not tree-shakeable, so it will include all operations in the project.
 * 2. It is not minifiable, so the string of a GraphQL query will be multiple times inside the bundle.
 * 3. It does not support dead code elimination, so it will add unused operations.
 *
 * Therefore it is highly recommended to use the babel or swc plugin for production.
 * Learn more about it here: https://the-guild.dev/graphql/codegen/plugins/presets/preset-client#reducing-bundle-size
 */
type Documents = {
  '\n  mutation CreateOrUpdateLocation($object: Locations_insert_input!) {\n    insert_Locations_one(\n      object: $object\n      on_conflict: {\n        constraint: Locations_pkey\n        update_columns: [\n          name\n          address\n          city\n          postalCode\n          state\n          country\n          coordinates\n          updatedAt\n        ]\n      }\n    ) {\n      id\n      name\n      address\n      city\n      postalCode\n      state\n      country\n      coordinates\n      createdAt\n      updatedAt\n    }\n  }\n': typeof types.CreateOrUpdateLocationDocument;
  '\n  query GetLocations($limit: Int, $offset: Int, $countryCode: String, $partyId: String, $dateFrom: String, $dateTo: String) {\n    Locations(\n      offset: $offset\n      limit: $limit\n    ) {\n      id\n      name\n      address\n      city\n      postalCode\n      state\n      country\n      coordinates\n      createdAt\n      updatedAt\n      ChargingStations {\n        id\n        isOnline\n        protocol\n        createdAt\n        updatedAt\n        Evses: VariableAttributes(\n          distinct_on: evseDatabaseId\n          where: {\n            evseDatabaseId: { _is_null: false }\n            Evse: { connectorId: { _is_null: false } }\n          }\n        ) {\n          Evse {\n            databaseId\n            id\n            connectorId\n            createdAt\n            updatedAt\n          }\n        }\n      }\n    }\n  }\n': typeof types.GetLocationsDocument;
  '\n  query GetLocationById($id: Int!) {\n    Locations(where: { id: { _eq: $id } }) {\n      id\n      name\n      address\n      city\n      postalCode\n      state\n      country\n      coordinates\n      createdAt\n      updatedAt\n      ChargingStations {\n        id\n        isOnline\n        protocol\n        createdAt\n        updatedAt\n        Evses: VariableAttributes(\n          distinct_on: evseDatabaseId\n          where: {\n            evseDatabaseId: { _is_null: false }\n            Evse: { connectorId: { _is_null: false } }\n          }\n        ) {\n          Evse {\n            databaseId\n            id\n            connectorId\n            createdAt\n            updatedAt\n          }\n        }\n      }\n    }\n  }\n': typeof types.GetLocationByIdDocument;
  '\n  query GetEvseById($locationId: Int!, $stationId: String!, $evseId: Int!) {\n    Locations(where: { id: { _eq: $locationId } }) {\n      id\n      ChargingStations(where: { id: { _eq: $stationId } }) {\n        id\n        Evses: VariableAttributes(\n          where: { evseDatabaseId: { _eq: $evseId } }\n        ) {\n          Evse {\n            databaseId\n            id\n            connectorId\n            createdAt\n            updatedAt\n          }\n        }\n      }\n    }\n  }\n': typeof types.GetEvseByIdDocument;
  '\n  query GetConnectorById($locationId: Int!, $stationId: String!, $evseId: Int!, $connectorId: Int!) {\n    Locations(where: { id: { _eq: $locationId } }) {\n      id\n      ChargingStations(where: { id: { _eq: $stationId } }) {\n        id\n        Evses: VariableAttributes(\n          where: { evseDatabaseId: { _eq: $evseId } }\n        ) {\n          Evse {\n            databaseId\n            id\n            connectorId\n            createdAt\n            updatedAt\n            Connectors: VariableAttributes(\n              where: { id: { _eq: $connectorId } }\n            ) {\n              id\n              createdAt\n              updatedAt\n            }\n          }\n        }\n      }\n    }\n  }\n': typeof types.GetConnectorByIdDocument;
  '\n  query GetTariffByKey($id: Int!, $countryCode: String!, $partyId: String!) {\n    Tariffs(where: { id: { _eq: $id }, Tenant: { countryCode: { _eq: $countryCode }, partyId: { _eq: $partyId } } }) {\n      authorizationAmount,\n      createdAt,\n      currency,\n      id,\n      paymentFee,\n      pricePerKwh,\n      pricePerMin,\n      pricePerSession,\n      stationId,\n      taxRate,\n      updatedAt\n    }\n  }\n': typeof types.GetTariffByKeyDocument;
  '\n  query GetTariffs($limit: Int, $offset: Int, $dateFrom: timestamptz, $dateTo: timestamptz, $countryCode: String, $partyId: String) {\n    Tariffs(\n      limit: $limit\n      offset: $offset\n      where: {\n        Tenant: { countryCode: { _eq: $countryCode }, partyId: { _eq: $partyId } }\n        updatedAt: { _gte: $dateFrom, _lte: $dateTo }\n      }\n    ) {\n      authorizationAmount,\n      createdAt,\n      currency,\n      id,\n      paymentFee,\n      pricePerKwh,\n      pricePerMin,\n      pricePerSession,\n      stationId,\n      taxRate,\n      updatedAt\n    }\n    Tariffs_aggregate(\n      where: {\n        Tenant: { countryCode: { _eq: $countryCode }, partyId: { _eq: $partyId } }\n        updatedAt: { _gte: $dateFrom, _lte: $dateTo }\n      }\n    ) {\n      aggregate {\n        count\n      }\n    }\n  }\n': typeof types.GetTariffsDocument;
  '\n  mutation CreateOrUpdateTariff($object: Tariffs_insert_input!) {\n    insert_Tariffs_one(\n      object: $object\n      on_conflict: {\n        constraint: Tariffs_pkey\n        update_columns: [authorizationAmount, createdAt, currency, paymentFee, pricePerKwh, pricePerMin, pricePerSession, stationId, taxRate, updatedAt]\n      }\n    ) {\n      id\n      authorizationAmount\n      createdAt\n      currency\n      paymentFee\n      pricePerKwh\n      pricePerMin\n      pricePerSession\n      stationId\n      taxRate\n      updatedAt\n    }\n  }\n': typeof types.CreateOrUpdateTariffDocument;
  '\n  mutation DeleteTariff($id: Int!) {\n    delete_Tariffs_by_pk(id: $id) {\n      id\n    }\n  }\n': typeof types.DeleteTariffDocument;
  '\n  query ReadAuthorizations($idToken: String, $type: String, $countryCode: String, $partyId: String) {\n    Authorizations(\n      where: {\n        IdToken: { idToken: { _eq: $idToken }, type: { _eq: $type } },\n        Tenant: { countryCode: { _eq: $countryCode }, partyId: { _eq: $partyId } },\n        IdTokenInfo: { IdToken: { IdTokenAdditionalInfos: {} } }\n      }\n    ) {\n      id\n      createdAt\n      updatedAt\n      tenantId\n      Tenant {\n        id\n        countryCode\n        partyId\n      }\n      IdToken {\n        id\n        idToken\n        type\n      }\n      IdTokenInfo {\n        id\n        IdToken {\n          id\n          idToken\n          IdTokenAdditionalInfos {\n            AdditionalInfo {\n              id\n            },\n            IdToken {\n              id\n            },\n            Tenant {\n              id\n            },\n            additionalInfoId,\n            createdAt,\n            idTokenId,\n            tenantId,\n            updatedAt\n          }\n        }\n      }\n    }\n  }\n': typeof types.ReadAuthorizationsDocument;
  '\n  mutation UpdateAuthorization($where: Authorizations_bool_exp!, $set: Authorizations_set_input!) {\n    update_Authorizations(where: $where, _set: $set) {\n      returning {\n        id\n        IdToken {\n          idToken\n          type\n        }\n        IdTokenInfo {\n          status\n          language1\n          groupIdTokenId\n        }\n        Tenant {\n          countryCode\n          partyId\n        }\n      }\n    }\n  }\n': typeof types.UpdateAuthorizationDocument;
  '\n  query GetTransactions(\n    $cpoCountryCode: String, $cpoPartyId: String, $mspCountryCode: String, $mspPartyId: String, $dateFrom: timestamptz, $dateTo: timestamptz, $offset: Int, $limit: Int, $endedOnly: Boolean\n  ) {\n    Transactions(\n      where: {\n        stationId: { _is_null: false } # Adjust as needed for your schema\n        # If you need to filter by station, use stationId or the correct relation\n        TransactionEvents: {\n          IdToken: {\n            Authorization: {\n             \n            }\n          }\n        }\n        updatedAt: { _gte: $dateFrom, _lte: $dateTo }\n      }\n      offset: $offset\n      limit: $limit\n      order_by: { createdAt: asc }\n    ) {\n      id\n      stationId\n      transactionId\n      isActive\n      chargingState\n      timeSpentCharging\n      totalKwh\n      stoppedReason\n      remoteStartId\n      totalCost\n      createdAt\n      updatedAt\n      # Removed customData, station, evse, transactionEvents, meterValues, startTransaction, stopTransaction fields\n      # Add correct relation fields if needed, e.g. Evse, TransactionEvents, MeterValues, StartTransaction, StopTransaction\n      Evse {\n        id\n      }\n      TransactionEvents {\n        id\n        eventType\n      }\n      MeterValues {\n        id\n      }\n      StartTransaction {\n        id\n      }\n      StopTransaction {\n        id\n      }\n    }\n    Transactions_aggregate(\n      where: {\n        stationId: { _is_null: false }\n        TransactionEvents: {\n          IdToken: {\n            Authorization: {\n              IdToken: {\n                \n              }\n            }\n          }\n        }\n        updatedAt: { _gte: $dateFrom, _lte: $dateTo }\n      }\n    ) {\n      aggregate {\n        count\n      }\n    }\n  }\n': typeof types.GetTransactionsDocument;
};
const documents: Documents = {
  '\n  mutation CreateOrUpdateLocation($object: Locations_insert_input!) {\n    insert_Locations_one(\n      object: $object\n      on_conflict: {\n        constraint: Locations_pkey\n        update_columns: [\n          name\n          address\n          city\n          postalCode\n          state\n          country\n          coordinates\n          updatedAt\n        ]\n      }\n    ) {\n      id\n      name\n      address\n      city\n      postalCode\n      state\n      country\n      coordinates\n      createdAt\n      updatedAt\n    }\n  }\n':
    types.CreateOrUpdateLocationDocument,
  '\n  query GetLocations($limit: Int, $offset: Int, $countryCode: String, $partyId: String, $dateFrom: String, $dateTo: String) {\n    Locations(\n      offset: $offset\n      limit: $limit\n    ) {\n      id\n      name\n      address\n      city\n      postalCode\n      state\n      country\n      coordinates\n      createdAt\n      updatedAt\n      ChargingStations {\n        id\n        isOnline\n        protocol\n        createdAt\n        updatedAt\n        Evses: VariableAttributes(\n          distinct_on: evseDatabaseId\n          where: {\n            evseDatabaseId: { _is_null: false }\n            Evse: { connectorId: { _is_null: false } }\n          }\n        ) {\n          Evse {\n            databaseId\n            id\n            connectorId\n            createdAt\n            updatedAt\n          }\n        }\n      }\n    }\n  }\n':
    types.GetLocationsDocument,
  '\n  query GetLocationById($id: Int!) {\n    Locations(where: { id: { _eq: $id } }) {\n      id\n      name\n      address\n      city\n      postalCode\n      state\n      country\n      coordinates\n      createdAt\n      updatedAt\n      ChargingStations {\n        id\n        isOnline\n        protocol\n        createdAt\n        updatedAt\n        Evses: VariableAttributes(\n          distinct_on: evseDatabaseId\n          where: {\n            evseDatabaseId: { _is_null: false }\n            Evse: { connectorId: { _is_null: false } }\n          }\n        ) {\n          Evse {\n            databaseId\n            id\n            connectorId\n            createdAt\n            updatedAt\n          }\n        }\n      }\n    }\n  }\n':
    types.GetLocationByIdDocument,
  '\n  query GetEvseById($locationId: Int!, $stationId: String!, $evseId: Int!) {\n    Locations(where: { id: { _eq: $locationId } }) {\n      id\n      ChargingStations(where: { id: { _eq: $stationId } }) {\n        id\n        Evses: VariableAttributes(\n          where: { evseDatabaseId: { _eq: $evseId } }\n        ) {\n          Evse {\n            databaseId\n            id\n            connectorId\n            createdAt\n            updatedAt\n          }\n        }\n      }\n    }\n  }\n':
    types.GetEvseByIdDocument,
  '\n  query GetConnectorById($locationId: Int!, $stationId: String!, $evseId: Int!, $connectorId: Int!) {\n    Locations(where: { id: { _eq: $locationId } }) {\n      id\n      ChargingStations(where: { id: { _eq: $stationId } }) {\n        id\n        Evses: VariableAttributes(\n          where: { evseDatabaseId: { _eq: $evseId } }\n        ) {\n          Evse {\n            databaseId\n            id\n            connectorId\n            createdAt\n            updatedAt\n            Connectors: VariableAttributes(\n              where: { id: { _eq: $connectorId } }\n            ) {\n              id\n              createdAt\n              updatedAt\n            }\n          }\n        }\n      }\n    }\n  }\n':
    types.GetConnectorByIdDocument,
  '\n  query GetTariffByKey($id: Int!, $countryCode: String!, $partyId: String!) {\n    Tariffs(where: { id: { _eq: $id }, Tenant: { countryCode: { _eq: $countryCode }, partyId: { _eq: $partyId } } }) {\n      authorizationAmount,\n      createdAt,\n      currency,\n      id,\n      paymentFee,\n      pricePerKwh,\n      pricePerMin,\n      pricePerSession,\n      stationId,\n      taxRate,\n      updatedAt\n    }\n  }\n':
    types.GetTariffByKeyDocument,
  '\n  query GetTariffs($limit: Int, $offset: Int, $dateFrom: timestamptz, $dateTo: timestamptz, $countryCode: String, $partyId: String) {\n    Tariffs(\n      limit: $limit\n      offset: $offset\n      where: {\n        Tenant: { countryCode: { _eq: $countryCode }, partyId: { _eq: $partyId } }\n        updatedAt: { _gte: $dateFrom, _lte: $dateTo }\n      }\n    ) {\n      authorizationAmount,\n      createdAt,\n      currency,\n      id,\n      paymentFee,\n      pricePerKwh,\n      pricePerMin,\n      pricePerSession,\n      stationId,\n      taxRate,\n      updatedAt\n    }\n    Tariffs_aggregate(\n      where: {\n        Tenant: { countryCode: { _eq: $countryCode }, partyId: { _eq: $partyId } }\n        updatedAt: { _gte: $dateFrom, _lte: $dateTo }\n      }\n    ) {\n      aggregate {\n        count\n      }\n    }\n  }\n':
    types.GetTariffsDocument,
  '\n  mutation CreateOrUpdateTariff($object: Tariffs_insert_input!) {\n    insert_Tariffs_one(\n      object: $object\n      on_conflict: {\n        constraint: Tariffs_pkey\n        update_columns: [authorizationAmount, createdAt, currency, paymentFee, pricePerKwh, pricePerMin, pricePerSession, stationId, taxRate, updatedAt]\n      }\n    ) {\n      id\n      authorizationAmount\n      createdAt\n      currency\n      paymentFee\n      pricePerKwh\n      pricePerMin\n      pricePerSession\n      stationId\n      taxRate\n      updatedAt\n    }\n  }\n':
    types.CreateOrUpdateTariffDocument,
  '\n  mutation DeleteTariff($id: Int!) {\n    delete_Tariffs_by_pk(id: $id) {\n      id\n    }\n  }\n':
    types.DeleteTariffDocument,
  '\n  query ReadAuthorizations($idToken: String, $type: String, $countryCode: String, $partyId: String) {\n    Authorizations(\n      where: {\n        IdToken: { idToken: { _eq: $idToken }, type: { _eq: $type } },\n        Tenant: { countryCode: { _eq: $countryCode }, partyId: { _eq: $partyId } },\n        IdTokenInfo: { IdToken: { IdTokenAdditionalInfos: {} } }\n      }\n    ) {\n      id\n      createdAt\n      updatedAt\n      tenantId\n      Tenant {\n        id\n        countryCode\n        partyId\n      }\n      IdToken {\n        id\n        idToken\n        type\n      }\n      IdTokenInfo {\n        id\n        IdToken {\n          id\n          idToken\n          IdTokenAdditionalInfos {\n            AdditionalInfo {\n              id\n            },\n            IdToken {\n              id\n            },\n            Tenant {\n              id\n            },\n            additionalInfoId,\n            createdAt,\n            idTokenId,\n            tenantId,\n            updatedAt\n          }\n        }\n      }\n    }\n  }\n':
    types.ReadAuthorizationsDocument,
  '\n  mutation UpdateAuthorization($where: Authorizations_bool_exp!, $set: Authorizations_set_input!) {\n    update_Authorizations(where: $where, _set: $set) {\n      returning {\n        id\n        IdToken {\n          idToken\n          type\n        }\n        IdTokenInfo {\n          status\n          language1\n          groupIdTokenId\n        }\n        Tenant {\n          countryCode\n          partyId\n        }\n      }\n    }\n  }\n':
    types.UpdateAuthorizationDocument,
  '\n  query GetTransactions(\n    $cpoCountryCode: String, $cpoPartyId: String, $mspCountryCode: String, $mspPartyId: String, $dateFrom: timestamptz, $dateTo: timestamptz, $offset: Int, $limit: Int, $endedOnly: Boolean\n  ) {\n    Transactions(\n      where: {\n        stationId: { _is_null: false } # Adjust as needed for your schema\n        # If you need to filter by station, use stationId or the correct relation\n        TransactionEvents: {\n          IdToken: {\n            Authorization: {\n             \n            }\n          }\n        }\n        updatedAt: { _gte: $dateFrom, _lte: $dateTo }\n      }\n      offset: $offset\n      limit: $limit\n      order_by: { createdAt: asc }\n    ) {\n      id\n      stationId\n      transactionId\n      isActive\n      chargingState\n      timeSpentCharging\n      totalKwh\n      stoppedReason\n      remoteStartId\n      totalCost\n      createdAt\n      updatedAt\n      # Removed customData, station, evse, transactionEvents, meterValues, startTransaction, stopTransaction fields\n      # Add correct relation fields if needed, e.g. Evse, TransactionEvents, MeterValues, StartTransaction, StopTransaction\n      Evse {\n        id\n      }\n      TransactionEvents {\n        id\n        eventType\n      }\n      MeterValues {\n        id\n      }\n      StartTransaction {\n        id\n      }\n      StopTransaction {\n        id\n      }\n    }\n    Transactions_aggregate(\n      where: {\n        stationId: { _is_null: false }\n        TransactionEvents: {\n          IdToken: {\n            Authorization: {\n              IdToken: {\n                \n              }\n            }\n          }\n        }\n        updatedAt: { _gte: $dateFrom, _lte: $dateTo }\n      }\n    ) {\n      aggregate {\n        count\n      }\n    }\n  }\n':
    types.GetTransactionsDocument,
};

/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 *
 *
 * @example
 * ```ts
 * const query = graphql(`query GetUser($id: ID!) { user(id: $id) { name } }`);
 * ```
 *
 * The query argument is unknown!
 * Please regenerate the types.
 */
export function graphql(source: string): unknown;

/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(
  source: '\n  mutation CreateOrUpdateLocation($object: Locations_insert_input!) {\n    insert_Locations_one(\n      object: $object\n      on_conflict: {\n        constraint: Locations_pkey\n        update_columns: [\n          name\n          address\n          city\n          postalCode\n          state\n          country\n          coordinates\n          updatedAt\n        ]\n      }\n    ) {\n      id\n      name\n      address\n      city\n      postalCode\n      state\n      country\n      coordinates\n      createdAt\n      updatedAt\n    }\n  }\n',
): (typeof documents)['\n  mutation CreateOrUpdateLocation($object: Locations_insert_input!) {\n    insert_Locations_one(\n      object: $object\n      on_conflict: {\n        constraint: Locations_pkey\n        update_columns: [\n          name\n          address\n          city\n          postalCode\n          state\n          country\n          coordinates\n          updatedAt\n        ]\n      }\n    ) {\n      id\n      name\n      address\n      city\n      postalCode\n      state\n      country\n      coordinates\n      createdAt\n      updatedAt\n    }\n  }\n'];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(
  source: '\n  query GetLocations($limit: Int, $offset: Int, $countryCode: String, $partyId: String, $dateFrom: String, $dateTo: String) {\n    Locations(\n      offset: $offset\n      limit: $limit\n    ) {\n      id\n      name\n      address\n      city\n      postalCode\n      state\n      country\n      coordinates\n      createdAt\n      updatedAt\n      ChargingStations {\n        id\n        isOnline\n        protocol\n        createdAt\n        updatedAt\n        Evses: VariableAttributes(\n          distinct_on: evseDatabaseId\n          where: {\n            evseDatabaseId: { _is_null: false }\n            Evse: { connectorId: { _is_null: false } }\n          }\n        ) {\n          Evse {\n            databaseId\n            id\n            connectorId\n            createdAt\n            updatedAt\n          }\n        }\n      }\n    }\n  }\n',
): (typeof documents)['\n  query GetLocations($limit: Int, $offset: Int, $countryCode: String, $partyId: String, $dateFrom: String, $dateTo: String) {\n    Locations(\n      offset: $offset\n      limit: $limit\n    ) {\n      id\n      name\n      address\n      city\n      postalCode\n      state\n      country\n      coordinates\n      createdAt\n      updatedAt\n      ChargingStations {\n        id\n        isOnline\n        protocol\n        createdAt\n        updatedAt\n        Evses: VariableAttributes(\n          distinct_on: evseDatabaseId\n          where: {\n            evseDatabaseId: { _is_null: false }\n            Evse: { connectorId: { _is_null: false } }\n          }\n        ) {\n          Evse {\n            databaseId\n            id\n            connectorId\n            createdAt\n            updatedAt\n          }\n        }\n      }\n    }\n  }\n'];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(
  source: '\n  query GetLocationById($id: Int!) {\n    Locations(where: { id: { _eq: $id } }) {\n      id\n      name\n      address\n      city\n      postalCode\n      state\n      country\n      coordinates\n      createdAt\n      updatedAt\n      ChargingStations {\n        id\n        isOnline\n        protocol\n        createdAt\n        updatedAt\n        Evses: VariableAttributes(\n          distinct_on: evseDatabaseId\n          where: {\n            evseDatabaseId: { _is_null: false }\n            Evse: { connectorId: { _is_null: false } }\n          }\n        ) {\n          Evse {\n            databaseId\n            id\n            connectorId\n            createdAt\n            updatedAt\n          }\n        }\n      }\n    }\n  }\n',
): (typeof documents)['\n  query GetLocationById($id: Int!) {\n    Locations(where: { id: { _eq: $id } }) {\n      id\n      name\n      address\n      city\n      postalCode\n      state\n      country\n      coordinates\n      createdAt\n      updatedAt\n      ChargingStations {\n        id\n        isOnline\n        protocol\n        createdAt\n        updatedAt\n        Evses: VariableAttributes(\n          distinct_on: evseDatabaseId\n          where: {\n            evseDatabaseId: { _is_null: false }\n            Evse: { connectorId: { _is_null: false } }\n          }\n        ) {\n          Evse {\n            databaseId\n            id\n            connectorId\n            createdAt\n            updatedAt\n          }\n        }\n      }\n    }\n  }\n'];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(
  source: '\n  query GetEvseById($locationId: Int!, $stationId: String!, $evseId: Int!) {\n    Locations(where: { id: { _eq: $locationId } }) {\n      id\n      ChargingStations(where: { id: { _eq: $stationId } }) {\n        id\n        Evses: VariableAttributes(\n          where: { evseDatabaseId: { _eq: $evseId } }\n        ) {\n          Evse {\n            databaseId\n            id\n            connectorId\n            createdAt\n            updatedAt\n          }\n        }\n      }\n    }\n  }\n',
): (typeof documents)['\n  query GetEvseById($locationId: Int!, $stationId: String!, $evseId: Int!) {\n    Locations(where: { id: { _eq: $locationId } }) {\n      id\n      ChargingStations(where: { id: { _eq: $stationId } }) {\n        id\n        Evses: VariableAttributes(\n          where: { evseDatabaseId: { _eq: $evseId } }\n        ) {\n          Evse {\n            databaseId\n            id\n            connectorId\n            createdAt\n            updatedAt\n          }\n        }\n      }\n    }\n  }\n'];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(
  source: '\n  query GetConnectorById($locationId: Int!, $stationId: String!, $evseId: Int!, $connectorId: Int!) {\n    Locations(where: { id: { _eq: $locationId } }) {\n      id\n      ChargingStations(where: { id: { _eq: $stationId } }) {\n        id\n        Evses: VariableAttributes(\n          where: { evseDatabaseId: { _eq: $evseId } }\n        ) {\n          Evse {\n            databaseId\n            id\n            connectorId\n            createdAt\n            updatedAt\n            Connectors: VariableAttributes(\n              where: { id: { _eq: $connectorId } }\n            ) {\n              id\n              createdAt\n              updatedAt\n            }\n          }\n        }\n      }\n    }\n  }\n',
): (typeof documents)['\n  query GetConnectorById($locationId: Int!, $stationId: String!, $evseId: Int!, $connectorId: Int!) {\n    Locations(where: { id: { _eq: $locationId } }) {\n      id\n      ChargingStations(where: { id: { _eq: $stationId } }) {\n        id\n        Evses: VariableAttributes(\n          where: { evseDatabaseId: { _eq: $evseId } }\n        ) {\n          Evse {\n            databaseId\n            id\n            connectorId\n            createdAt\n            updatedAt\n            Connectors: VariableAttributes(\n              where: { id: { _eq: $connectorId } }\n            ) {\n              id\n              createdAt\n              updatedAt\n            }\n          }\n        }\n      }\n    }\n  }\n'];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(
  source: '\n  query GetTariffByKey($id: Int!, $countryCode: String!, $partyId: String!) {\n    Tariffs(where: { id: { _eq: $id }, Tenant: { countryCode: { _eq: $countryCode }, partyId: { _eq: $partyId } } }) {\n      authorizationAmount,\n      createdAt,\n      currency,\n      id,\n      paymentFee,\n      pricePerKwh,\n      pricePerMin,\n      pricePerSession,\n      stationId,\n      taxRate,\n      updatedAt\n    }\n  }\n',
): (typeof documents)['\n  query GetTariffByKey($id: Int!, $countryCode: String!, $partyId: String!) {\n    Tariffs(where: { id: { _eq: $id }, Tenant: { countryCode: { _eq: $countryCode }, partyId: { _eq: $partyId } } }) {\n      authorizationAmount,\n      createdAt,\n      currency,\n      id,\n      paymentFee,\n      pricePerKwh,\n      pricePerMin,\n      pricePerSession,\n      stationId,\n      taxRate,\n      updatedAt\n    }\n  }\n'];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(
  source: '\n  query GetTariffs($limit: Int, $offset: Int, $dateFrom: timestamptz, $dateTo: timestamptz, $countryCode: String, $partyId: String) {\n    Tariffs(\n      limit: $limit\n      offset: $offset\n      where: {\n        Tenant: { countryCode: { _eq: $countryCode }, partyId: { _eq: $partyId } }\n        updatedAt: { _gte: $dateFrom, _lte: $dateTo }\n      }\n    ) {\n      authorizationAmount,\n      createdAt,\n      currency,\n      id,\n      paymentFee,\n      pricePerKwh,\n      pricePerMin,\n      pricePerSession,\n      stationId,\n      taxRate,\n      updatedAt\n    }\n    Tariffs_aggregate(\n      where: {\n        Tenant: { countryCode: { _eq: $countryCode }, partyId: { _eq: $partyId } }\n        updatedAt: { _gte: $dateFrom, _lte: $dateTo }\n      }\n    ) {\n      aggregate {\n        count\n      }\n    }\n  }\n',
): (typeof documents)['\n  query GetTariffs($limit: Int, $offset: Int, $dateFrom: timestamptz, $dateTo: timestamptz, $countryCode: String, $partyId: String) {\n    Tariffs(\n      limit: $limit\n      offset: $offset\n      where: {\n        Tenant: { countryCode: { _eq: $countryCode }, partyId: { _eq: $partyId } }\n        updatedAt: { _gte: $dateFrom, _lte: $dateTo }\n      }\n    ) {\n      authorizationAmount,\n      createdAt,\n      currency,\n      id,\n      paymentFee,\n      pricePerKwh,\n      pricePerMin,\n      pricePerSession,\n      stationId,\n      taxRate,\n      updatedAt\n    }\n    Tariffs_aggregate(\n      where: {\n        Tenant: { countryCode: { _eq: $countryCode }, partyId: { _eq: $partyId } }\n        updatedAt: { _gte: $dateFrom, _lte: $dateTo }\n      }\n    ) {\n      aggregate {\n        count\n      }\n    }\n  }\n'];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(
  source: '\n  mutation CreateOrUpdateTariff($object: Tariffs_insert_input!) {\n    insert_Tariffs_one(\n      object: $object\n      on_conflict: {\n        constraint: Tariffs_pkey\n        update_columns: [authorizationAmount, createdAt, currency, paymentFee, pricePerKwh, pricePerMin, pricePerSession, stationId, taxRate, updatedAt]\n      }\n    ) {\n      id\n      authorizationAmount\n      createdAt\n      currency\n      paymentFee\n      pricePerKwh\n      pricePerMin\n      pricePerSession\n      stationId\n      taxRate\n      updatedAt\n    }\n  }\n',
): (typeof documents)['\n  mutation CreateOrUpdateTariff($object: Tariffs_insert_input!) {\n    insert_Tariffs_one(\n      object: $object\n      on_conflict: {\n        constraint: Tariffs_pkey\n        update_columns: [authorizationAmount, createdAt, currency, paymentFee, pricePerKwh, pricePerMin, pricePerSession, stationId, taxRate, updatedAt]\n      }\n    ) {\n      id\n      authorizationAmount\n      createdAt\n      currency\n      paymentFee\n      pricePerKwh\n      pricePerMin\n      pricePerSession\n      stationId\n      taxRate\n      updatedAt\n    }\n  }\n'];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(
  source: '\n  mutation DeleteTariff($id: Int!) {\n    delete_Tariffs_by_pk(id: $id) {\n      id\n    }\n  }\n',
): (typeof documents)['\n  mutation DeleteTariff($id: Int!) {\n    delete_Tariffs_by_pk(id: $id) {\n      id\n    }\n  }\n'];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(
  source: '\n  query ReadAuthorizations($idToken: String, $type: String, $countryCode: String, $partyId: String) {\n    Authorizations(\n      where: {\n        IdToken: { idToken: { _eq: $idToken }, type: { _eq: $type } },\n        Tenant: { countryCode: { _eq: $countryCode }, partyId: { _eq: $partyId } },\n        IdTokenInfo: { IdToken: { IdTokenAdditionalInfos: {} } }\n      }\n    ) {\n      id\n      createdAt\n      updatedAt\n      tenantId\n      Tenant {\n        id\n        countryCode\n        partyId\n      }\n      IdToken {\n        id\n        idToken\n        type\n      }\n      IdTokenInfo {\n        id\n        IdToken {\n          id\n          idToken\n          IdTokenAdditionalInfos {\n            AdditionalInfo {\n              id\n            },\n            IdToken {\n              id\n            },\n            Tenant {\n              id\n            },\n            additionalInfoId,\n            createdAt,\n            idTokenId,\n            tenantId,\n            updatedAt\n          }\n        }\n      }\n    }\n  }\n',
): (typeof documents)['\n  query ReadAuthorizations($idToken: String, $type: String, $countryCode: String, $partyId: String) {\n    Authorizations(\n      where: {\n        IdToken: { idToken: { _eq: $idToken }, type: { _eq: $type } },\n        Tenant: { countryCode: { _eq: $countryCode }, partyId: { _eq: $partyId } },\n        IdTokenInfo: { IdToken: { IdTokenAdditionalInfos: {} } }\n      }\n    ) {\n      id\n      createdAt\n      updatedAt\n      tenantId\n      Tenant {\n        id\n        countryCode\n        partyId\n      }\n      IdToken {\n        id\n        idToken\n        type\n      }\n      IdTokenInfo {\n        id\n        IdToken {\n          id\n          idToken\n          IdTokenAdditionalInfos {\n            AdditionalInfo {\n              id\n            },\n            IdToken {\n              id\n            },\n            Tenant {\n              id\n            },\n            additionalInfoId,\n            createdAt,\n            idTokenId,\n            tenantId,\n            updatedAt\n          }\n        }\n      }\n    }\n  }\n'];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(
  source: '\n  mutation UpdateAuthorization($where: Authorizations_bool_exp!, $set: Authorizations_set_input!) {\n    update_Authorizations(where: $where, _set: $set) {\n      returning {\n        id\n        IdToken {\n          idToken\n          type\n        }\n        IdTokenInfo {\n          status\n          language1\n          groupIdTokenId\n        }\n        Tenant {\n          countryCode\n          partyId\n        }\n      }\n    }\n  }\n',
): (typeof documents)['\n  mutation UpdateAuthorization($where: Authorizations_bool_exp!, $set: Authorizations_set_input!) {\n    update_Authorizations(where: $where, _set: $set) {\n      returning {\n        id\n        IdToken {\n          idToken\n          type\n        }\n        IdTokenInfo {\n          status\n          language1\n          groupIdTokenId\n        }\n        Tenant {\n          countryCode\n          partyId\n        }\n      }\n    }\n  }\n'];
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(
  source: '\n  query GetTransactions(\n    $cpoCountryCode: String, $cpoPartyId: String, $mspCountryCode: String, $mspPartyId: String, $dateFrom: timestamptz, $dateTo: timestamptz, $offset: Int, $limit: Int, $endedOnly: Boolean\n  ) {\n    Transactions(\n      where: {\n        stationId: { _is_null: false } # Adjust as needed for your schema\n        # If you need to filter by station, use stationId or the correct relation\n        TransactionEvents: {\n          IdToken: {\n            Authorization: {\n             \n            }\n          }\n        }\n        updatedAt: { _gte: $dateFrom, _lte: $dateTo }\n      }\n      offset: $offset\n      limit: $limit\n      order_by: { createdAt: asc }\n    ) {\n      id\n      stationId\n      transactionId\n      isActive\n      chargingState\n      timeSpentCharging\n      totalKwh\n      stoppedReason\n      remoteStartId\n      totalCost\n      createdAt\n      updatedAt\n      # Removed customData, station, evse, transactionEvents, meterValues, startTransaction, stopTransaction fields\n      # Add correct relation fields if needed, e.g. Evse, TransactionEvents, MeterValues, StartTransaction, StopTransaction\n      Evse {\n        id\n      }\n      TransactionEvents {\n        id\n        eventType\n      }\n      MeterValues {\n        id\n      }\n      StartTransaction {\n        id\n      }\n      StopTransaction {\n        id\n      }\n    }\n    Transactions_aggregate(\n      where: {\n        stationId: { _is_null: false }\n        TransactionEvents: {\n          IdToken: {\n            Authorization: {\n              IdToken: {\n                \n              }\n            }\n          }\n        }\n        updatedAt: { _gte: $dateFrom, _lte: $dateTo }\n      }\n    ) {\n      aggregate {\n        count\n      }\n    }\n  }\n',
): (typeof documents)['\n  query GetTransactions(\n    $cpoCountryCode: String, $cpoPartyId: String, $mspCountryCode: String, $mspPartyId: String, $dateFrom: timestamptz, $dateTo: timestamptz, $offset: Int, $limit: Int, $endedOnly: Boolean\n  ) {\n    Transactions(\n      where: {\n        stationId: { _is_null: false } # Adjust as needed for your schema\n        # If you need to filter by station, use stationId or the correct relation\n        TransactionEvents: {\n          IdToken: {\n            Authorization: {\n             \n            }\n          }\n        }\n        updatedAt: { _gte: $dateFrom, _lte: $dateTo }\n      }\n      offset: $offset\n      limit: $limit\n      order_by: { createdAt: asc }\n    ) {\n      id\n      stationId\n      transactionId\n      isActive\n      chargingState\n      timeSpentCharging\n      totalKwh\n      stoppedReason\n      remoteStartId\n      totalCost\n      createdAt\n      updatedAt\n      # Removed customData, station, evse, transactionEvents, meterValues, startTransaction, stopTransaction fields\n      # Add correct relation fields if needed, e.g. Evse, TransactionEvents, MeterValues, StartTransaction, StopTransaction\n      Evse {\n        id\n      }\n      TransactionEvents {\n        id\n        eventType\n      }\n      MeterValues {\n        id\n      }\n      StartTransaction {\n        id\n      }\n      StopTransaction {\n        id\n      }\n    }\n    Transactions_aggregate(\n      where: {\n        stationId: { _is_null: false }\n        TransactionEvents: {\n          IdToken: {\n            Authorization: {\n              IdToken: {\n                \n              }\n            }\n          }\n        }\n        updatedAt: { _gte: $dateFrom, _lte: $dateTo }\n      }\n    ) {\n      aggregate {\n        count\n      }\n    }\n  }\n'];

export function graphql(source: string) {
  return (documents as any)[source] ?? {};
}

export type DocumentType<TDocumentNode extends DocumentNode<any, any>> =
  TDocumentNode extends DocumentNode<infer TType, any> ? TType : never;
